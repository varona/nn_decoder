"""
Compute X error pattern data: probability distribution of plaquette excitations
in the semion code when X errors occurres. Each pattern is labeled by the set
of edges where the X operators are applied and is stored in PATTERN_PATH.
"""

import numpy as np
import os
import time
from multiprocessing import Pool, current_process
from functools import partial
from numba import njit

from hexagonal_lattice import _mod, HexagonalLattice


PATTERN_PATH = "../pattern"


def pattern2dec(pattern, set_list, base, add_len=True):
    """Maps patterns into decimal numbers."""
    if add_len:
        p = np.insert(pattern, 0, np.size(pattern))
    else: p = pattern.copy()
    p_new = p.copy()
    for i in range(np.size(p)):
        p_new[i] = np.squeeze(np.argwhere(p[i]==set_list[i]))
    return np.ravel_multi_index(p_new, base[:np.size(p)])


def load_pattern_data():
    """Load pattern data into memory.

    Returns:
        pattern_dec_list: list of pattern integer identifiers.
        pattern_pdata_list: list of 1d arrays (float). Each 1d array contains
            the probability distribution of different plaquette excitations.
        pattern_cdata_list: list of 1d arrays (int). Each 1d array contains the
            classification of each c(z_Q) according to the plaquette excitation
            generated by z_Q.
        set_list:  list of 1d arrays (int). Necessary to map pattern into
            decimal number.
        base: list of integers. Necessary to map pattern into decimal number.
    """
    pattern_list = []
    pattern_pdata_list = []
    pattern_cdata_list = []
    for fname in os.listdir(PATTERN_PATH):
        if not fname.endswith('.npz'): continue
        string = fname[:-4]
        string = string.replace('[','')
        string = string.replace(']','')
        string = string.strip()
        string = string.split()
        # Add length to distinguish cases such as [0] and [0,1]
        pattern_list.append([len(string)]+[int(s) for s in string]) 
        data = np.load(os.path.join(PATTERN_PATH, fname))
        pattern_pdata_list.append(data['prob_dist'])
        pattern_cdata_list.append(data['c_class'])

    if len(pattern_list)==0:
        return np.array([]), [], [], [], []

    set_list = [set() for i in range(np.max([len(p) for p in pattern_list]))]
    for i in range(np.max([len(p) for p in pattern_list])):
        for p in pattern_list:
            try:
                set_list[i].add(p[i])
            except:
                continue
    set_list = [np.sort(list(s)) for s in set_list]

    base = [len(s) for s in set_list]
    pattern_dec_list = np.zeros(len(pattern_list), dtype=np.int64)
    for j,p in enumerate(pattern_list):
        pattern_dec_list[j] = pattern2dec(
            np.array(p, dtype=np.int64), set_list, base, add_len=False)

    perm = np.argsort(pattern_dec_list)
    pattern_dec_list = pattern_dec_list[perm]
    pattern_pdata_list = [pattern_pdata_list[i] for i in perm]
    pattern_cdata_list = [pattern_cdata_list[i] for i in perm]

    return pattern_dec_list, pattern_pdata_list, pattern_cdata_list, set_list, base


pattern_dec_list, pattern_pdata_list, pattern_cdata_list, set_list, base = load_pattern_data()
F012 = np.load(os.path.join(PATTERN_PATH, 'F.npy'))


def de2bi(d, n):
    """Decimal number to binary number."""
    d = np.atleast_1d(d)
    power = 2**np.arange(n)
    return np.int_(np.floor((d[...,None]%(2*power))/power))


def bi2de(x):
    """Binary number to decimal number."""
    x = np.atleast_2d(x)
    result = np.zeros(x.shape[0], dtype=int)
    for k,row in enumerate(x):
        y = 0
        for i,j in enumerate(row):
            y += j<<i
        result[k] = y
    return result

def shift_f(f, shift):
    """Given phases F(\vec i) compute F(\vec i + \vec \alpha_{shift}).
    """
    n = np.int(np.log2(len(f)))
    f_shift = np.zeros(2**n, dtype='complex64')
    for i in range(2**n):
        i_vec = de2bi(i, n)
        i_shift = bi2de(np.mod(i_vec + shift, 2))
        f_shift[i] = f[i_shift]
    return f_shift


def _pauli_coeff(j, n, f):
    """c(z_Q) = \sum_i (-1)^{\alpha_Q \cdot i} F(i)
    """
    alpha_z = de2bi(j, n)
    c = 0
    for i in range(2**n):
        i_vec = de2bi(i, n)
        c = c + (-1)**(np.sum(i_vec*alpha_z))*f[i]
    return c


def pauli_coeff(f):
    """Compute Pauli coefficients of F.
    """
    n = np.int(np.log2(len(f)))

    # Serial
    if "daemon" in current_process()._config:
        c = np.zeros(2**n, dtype='complex64')
        for j in range(2**n):
            c[j] = _pauli_coeff(j,n,f)
    # Parallel
    else:
        with Pool() as pool:
            c = pool.map(partial(_pauli_coeff, f=f, n=n), range(2**n))
    return np.array(c)/2**n


def probability(c, alpha_plaquette, classify=False):
    """Given Pauli coefficients c(z_Q), obtain probabilities of getting a
    certain plaquette configuration. Optional: classify non-zero Pauli
    coefficients according to plaquette configuration."""
    c = np.conjugate(c)
    n = np.int(np.log2(len(c)))
    # compute state X| 0 0 0 0 0 >
    n_p = alpha_plaquette.shape[0] # number of plaquettes
    c_sum = np.zeros(2**n_p, dtype='complex64')
    if classify: c_class = -np.ones(2**n, dtype=int)
    for j in range(2**n):
        if c[j]==0: continue
        alpha_z = de2bi(j,n)
        plaquette_state = np.mod(
            np.matmul(alpha_z, alpha_plaquette.transpose()), 2)
        ind = bi2de(plaquette_state)
        c_sum[ind] = c_sum[ind] + c[j]
        if classify:
            c_class[j] =  ind
    if classify: return np.abs(c_sum)**2, c_class
    return np.abs(c_sum)**2


def map_f(f, mapping, n_new):
    """Obtain suitable mapping for function _map_f and call it."""
    mapping_new = -np.ones([n_new], dtype=int)
    for j in range(n_new):
        if j in mapping:
            mapping_new[j] = np.argwhere(mapping==j)
    f_mapped = _map_f(f, mapping_new, n_new)
    return f_mapped


def _map_f(f, perm, n_new, n=5):
    """Map F using permutations. Qubits outside conn needed are set to -1.
    Position in perm vector identifies qubit in new mapped system, number is 
    qubit in old system (5 qubits)."""
    f_mapped = np.zeros([2**n_new], dtype='complex64')
    for i in range(2**n_new):
        i_vec_mapped = np.squeeze(de2bi(i, n_new))
        i_vec = np.zeros(n, dtype=int);
        for j in range(len(perm)):
            if perm[j]!=-1:
                i_vec[perm[j]] = i_vec_mapped[j]
        f_mapped[i] = f[bi2de(i_vec)]
    return f_mapped


def plaquette_probabilities(mapping, alpha_plaquette, e_orientation):
    """Map length-one F phases to our system using mapping. Then multiply all
    phases to obtain f_total and get plaquette configuration probabilities."""
    n = len(e_orientation)
    f_phases = np.zeros([mapping.shape[0], 2**n], dtype='complex64')
    for i in range(mapping.shape[0]):
        f_phases[i, :] = map_f(
            F012[e_orientation[mapping[i, 2]], :], mapping[i, :], n)
    f_total = np.ones(2**n, dtype='complex64')
    alpha_path = np.zeros([mapping.shape[0],n], dtype=bool)
    for i,f in enumerate(f_phases):
        alpha_path[i, mapping[i,2]] = True
        shift = np.mod(np.sum(alpha_path[0:i,:],axis=0),2)
        f_total = f_total*shift_f(f, shift)
    c = pauli_coeff(f_total)
    prob_dist, c_class = probability(c, alpha_plaquette, classify=True)
    return prob_dist, c, c_class


def map_length_one_string(x_string, lattice):
    """Given string edges, returns mapping to each length-one string, where
    positions in map are in small 5-qubit system and numbers are in old big
    system. Following the labeling given in Fig. 7. """
    mapping = np.zeros([len(x_string), 5], dtype=int)
    for i, e in enumerate(x_string):
        mapping[i, 2] = e
        position = np.squeeze(lattice.edge_position(e))

        edges_1_2 =  lattice.vertex2edge(lattice.e_vertex[e,0], both=False)
        edges_1_2 = np.setdiff1d(edges_1_2, e)

        edges_4_5 = lattice.vertex2edge(lattice.e_vertex[e,1], both=False)
        edges_4_5 = np.setdiff1d(edges_4_5, e)

        if lattice.e_orientation[e] == 0:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[0] < position[0]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[0] < position[0]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]

        elif lattice.e_orientation[e] == 1:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[1] == position[1]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[1] > position[1]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]

        elif lattice.e_orientation[e] == 2:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[1] == position[1]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[1] < position[1]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]
    return mapping


@njit
def move_string(n_row, n_col, x_string_pos):
    """Move string given by edge positions x_string_pos to the lower left
    corner of a lattice with n_row and n_col.
    """
    while True:
        if np.all(_mod(n_row, n_col, x_string_pos - np.array([1, 3], 
            np.float64)) == x_string_pos - np.array([1, 3], np.float64)):
            x_string_pos = x_string_pos - np.array([1, 3], np.float64)
        elif np.all(_mod(n_row, n_col, x_string_pos - np.array([2, 0], 
            np.float64)) == x_string_pos - np.array([2, 0], np.float64)):
            x_string_pos = x_string_pos - np.array([2, 0], np.float64)
        else:
            break
    return x_string_pos


@njit('float64[:,:](int64, int64, float64[:,:])')
def move_away_boundary_e(n_row, n_col, position):
    """Determine if positions of group of edges go through a lattice boundary
    and move it away."""
    ymin = 0.5
    ymax = n_row*3-1
    def xmin(x): return 3*x - 1
    def xmax(x): return 3*(x-2*n_col+1) - 1

    x_m_array = np.zeros(position.shape[0], dtype=np.float64)

    y_max = np.max(position[:, 1])
    y_min = np.min(position[:, 1])
    s = 1
    i = 1
    while y_min == ymin and y_max == ymax:
        position = _mod(n_row, n_col, position + np.array([s*1, 3]))
        s = -s
        y_min = np.min(position[:, 1])
        y_max = np.max(position[:, 1])
        i = i + 1
        assert i < n_row, 'String goes all around system.'
    i = 1
    for j in range(position.shape[0]):
        x_m_array[j] = xmax(position[j, 0])-position[j, 1]
    x_max = np.min(np.abs(x_m_array))

    for j in range(position.shape[0]):
        x_m_array[j] = xmin(position[j, 0])-position[j, 1]
    x_min = np.min(np.abs(x_m_array))
    while x_min == 0 and x_max == 0:
        position = _mod(n_row, n_col, position + np.array([2, 0]))
        for j in range(position.shape[0]):
            x_m_array[j] = xmax(position[j, 0])-position[j, 1]
        x_max = np.min(np.abs(x_m_array))

        for j in range(position.shape[0]):
            x_m_array[j] = xmin(position[j, 0])-position[j, 1]
        x_min = np.min(np.abs(x_m_array))
        i = i + 1
        assert i < n_col, 'String goes all around system.'
    return position


@njit('int64[:,:](int64, int64, int64[:,:])')
def move_away_boundary_p(n_row, n_col, position):
    """Determine if positions of group of plaquettes go through a lattice 
    boundary and move it away."""
    ymin = 2
    ymax = n_row*3-1
    def xmin(x): return 3*x - 4
    def xmax(x): return 3*(x-2*n_col+2) - 4

    x_m_array = np.zeros(position.shape[0], dtype=np.int64)

    y_max = np.max(position[:, 1])
    y_min = np.min(position[:, 1])
    s = 1
    i = 1
    while y_min == ymin and y_max == ymax:
        position = _mod(
            n_row, n_col, position + np.array([s*1, 3], dtype=np.int64))
        s = -s
        y_min = np.min(position[:, 1])
        y_max = np.max(position[:, 1])
        i = i + 1
        assert i < n_row, 'String goes all around system.'
    i = 1
    for j in range(position.shape[0]):
        x_m_array[j] = xmax(position[j, 0])-position[j, 1]
    x_max = np.min(np.abs(x_m_array))

    for j in range(position.shape[0]):
        x_m_array[j] = xmin(position[j, 0])-position[j, 1]
    x_min = np.min(np.abs(x_m_array))
    while x_min == 0 and x_max == 0:
        position = _mod(
            n_row, n_col, position + np.array([2, 0], dtype=np.int64))

        for j in range(position.shape[0]):
            x_m_array[j] = xmax(position[j, 0])-position[j, 1]
        x_max = np.min(np.abs(x_m_array))

        for j in range(position.shape[0]):
            x_m_array[j] = xmin(position[j, 0])-position[j, 1]
        x_min = np.min(np.abs(x_m_array))

        i = i + 1
        assert i < n_col, 'String goes all around system.'
    return position


def group_edges(edge, lattice, direct=True):
    """Given edge list, group edges which are adjacent.
    
    Args:
        edge (1d array): edge indices or bool array of length
            lattice.n_edge.
        lattice (lattice object).
        direct (bool): direct lattice grouping or reciprocal.

    Returns:
        edge_group_list (list): list of 1d arrays int. Each 1d array contains 
        edge indices.
    """
    if direct:
        edge2vp = lattice.edge2vertex
    else:
        raise NotImplementedError(
            'Uncomment and use edge2plaquette in hexagonal lattice.')
        # edge2vp = lattice.edge2plaquette
    if edge.dtype == bool:
        n_edge = np.sum(edge)
        edge_group = np.concatenate(
            (np.argwhere(edge), -np.ones((n_edge, 1), dtype=int)), axis=1)
    else:
        n_edge = len(edge)
        edge_group = np.concatenate(
            (np.transpose(np.atleast_2d(edge)), -np.ones((n_edge, 1),
            dtype=int)), 
            axis=1)
    if n_edge == 0:
        return []
    for i in range(n_edge):
        if edge_group[i, 1] == -1:
            edge_group[i, 1] = np.max(edge_group[:, 1])+1
            check = [i]
        else:
            continue
        while check:
            for j in range(n_edge):
                if check[0] == j or edge_group[j, 1] != -1:
                    continue
                intersect = np.intersect1d(
                    edge2vp(edge_group[check[0], 0]), 
                    edge2vp(edge_group[j, 0]))
                if len(intersect) > 0:
                    edge_group[j, 1] = edge_group[check[0], 1]
                    check.append(j)
            check.pop(0)
    edge_group_list = []
    for i in range(np.max(edge_group[:, 1])+1):
        edge_group_list.append(edge_group[edge_group[:, 1] == i, 0])
    return edge_group_list


def x_error_pattern(x_string, 
                    lattice, 
                    lattice_map=HexagonalLattice(6, 6), 
                    plot=False):
    """Given a set of connected edges, x_string, identify it uniquely with a 
    pattern.
    
    A pattern is the set of edge indices where x_string lives when mapped into
    the lower left corner of lattice_map.

    Args:
        x_string (1d array int): adjacent edge indices.
        lattice (lattice object): original lattice where x_string is found.
        lattice_map (lattice object): where x_string is mapped.
        plot (bool): whether to plot x_string in the new and the original 
            lattice.
    Returns:
        pattern (1d array int): edge indices where x_string is located in
            lattice_map.
    """

    x_string_pos = lattice.edge_position(x_string)
    x_string_pos = move_away_boundary_e(
        lattice.n_row, lattice.n_col, x_string_pos)

    # Determine if string goes through a boundary and move it out of boundary
    x_string_pos = move_away_boundary_e(
        lattice_map.n_row, lattice_map.n_col, x_string_pos)
    # Move string to lower left corner
    x_string_pos = move_string(
        lattice_map.n_row, lattice_map.n_col, x_string_pos)
    # Mapped to vertices in small system
    pattern = np.sort(lattice_map.e_position2edge(x_string_pos))

    # Plot results
    if plot:
        lattice_map.plot_lattice(e_numbers=True)
        lattice_map.plot_error(pattern)
        lattice.plot_lattice(e_numbers=True)
        x_error = np.zeros(lattice.n_edge, dtype=bool)
        x_error[x_string] = True
        lattice.plot_error(x_error)

    return pattern


def compute_pattern(pattern, 
                    max_length, 
                    lattice=HexagonalLattice(6, 6), 
                    save=True):
    """Given a pattern, compute data and optionally store it.
    
    Args:
        pattern (1d array int): edge indices of the lattice.
        max_length (int): only compute pattern data if |Conn(pattern)| <= 
            max_length.
        lattice (lattice object): lattice into which patterns are mapped.
        save (bool): whether to save pattern data computed.

    Returns: False if pattern not computed, otherwise prob_dist (1d array  
        float) and c_class (1d array int).
    """
    pattern = np.sort(pattern)

    vertex = np.unique(lattice.edge2vertex(pattern))
    edge = lattice.vertex2edge(vertex, both=False)
    if len(edge)>max_length: return False
    print(f'Computing pattern: {pattern}, length {len(edge)}...')

    # Sort plaquettes in \cal{B}_{pattern}
    plaquette = np.unique(lattice.v_plaquette[vertex])
    p_position = move_away_boundary_p(
        lattice.n_row, lattice.n_col, 
        np.atleast_2d(lattice.p_position[plaquette, :]))
    ind = np.lexsort((p_position[:,1], p_position[:,0]))
    plaquette = plaquette[ind]

    # Sort edges in Conn(pattern)
    e_position = move_away_boundary_e(
        lattice.n_row, lattice.n_col, lattice.edge_position(edge))
    ind = np.lexsort((e_position[:,1], e_position[:,0]))
    edge = edge[ind]
    e_orientation = lattice.e_orientation[edge]

    # Map for F phases of each length-one string
    mapping = map_length_one_string(pattern, lattice)
    for i in range(np.shape(mapping)[0]):
        for j in range(np.shape(mapping)[1]):
            mapping[i,j] = np.argwhere(mapping[i,j]==edge)

    # Build alpha plaquette
    n = len(edge)
    alpha_plaquette = np.zeros([len(plaquette), n], dtype=bool)
    for i in range(len(plaquette)):
        p_edge = np.squeeze(lattice.plaquette2edge(plaquette[i]))
        for e in p_edge:
            if e in edge:
                ind = np.argwhere(edge==e)
                alpha_plaquette[i, ind] = True

    # Compute probabilities
    prob_dist, c, c_class = plaquette_probabilities(
        mapping, alpha_plaquette, e_orientation)

    # Save results
    if save:
        np.savez(os.path.join(PATTERN_PATH, str(pattern)),
                 prob_dist=prob_dist, c=c, c_class=c_class)
        print(f'Pattern saved in {os.path.join(PATTERN_PATH, str(pattern))}')
    return prob_dist, c_class


def compute_all_patterns(max_length=14):
    """Compute and save all patterns with |Conn(pattern)| <= max_length.
    """
    end_time = time.time()
    for _ in range(int(1e6)):
        p_X = 0.2
        lattice = HexagonalLattice(6,6)
        x_error = np.random.choice(2, lattice.n_edge, p=[1-p_X, p_X])
        x_error = x_error.astype(bool)
        x_error_group = group_edges(x_error, lattice, direct=True)
        for x_string in x_error_group:
            try:
                pattern = x_error_pattern(
                    x_string, lattice, HexagonalLattice(6, 6))
            except Exception as error:
                print("Pattern error "+repr(error))
                continue

            if os.path.isfile(os.path.join(PATTERN_PATH, str(pattern)+'.npz')):
                continue

            try:
                start_time = time.time()
                result = compute_pattern(pattern, max_length, save=True)
                if result:
                    end_time = time.time()
                    print('Elapsed time %s minutes' 
                    % str((end_time - start_time)/60.0))
            except Exception as error:
                print(repr(error))

        # if no new pattern found in last 300 seconds: return
        if time.time() - end_time > 300:
            print('Pattern data ready.')
            return

if __name__=='__main__':
    compute_all_patterns()
