"""
Compute X error pattern data: probability distribution of plaquette excitations
in the semion code when X errors occurres. Each pattern is labeled by the set
of edges where the X operators are applied and is stored in PATTERN_PATH.
"""

import numpy as np
import os
import time
from multiprocessing import Pool, current_process
from functools import partial
from numba import njit

from hexagonal_lattice import _mod, HexagonalLattice


PATTERN_PATH = "../pattern"


def pattern2dec(pattern, set_list, base, add_len=True):
    """Maps patterns into decimal numbers."""
    if add_len:
        p = np.insert(pattern, 0, np.size(pattern))
    else: p = pattern.copy()
    p_new = p.copy()
    for i in range(np.size(p)):
        p_new[i] = np.squeeze(np.argwhere(p[i]==set_list[i]))
    return np.ravel_multi_index(p_new, base[:np.size(p)])


def load_pattern_data():
    """Load pattern data into memory.

    Returns:
        pattern_dec_list: list of pattern integer identifiers.
        pattern_pdata_list: list of 1d arrays (float). Each 1d array contains
            the probability distribution of different plaquette excitations.
        pattern_cdata_list: list of 1d arrays (int). Each 1d array contains the
            classification of each c(Z_Q) according to the plaquette excitation
            generated by Z_Q.
        set_list:  list of 1d arrays (int). Necessary to map pattern into
            decimal number.
        base: list of integers. Necessary to map pattern into decimal number.
    """
    pattern_list = []
    pattern_pdata_list = []
    pattern_cdata_list = []
    for fname in os.listdir(PATTERN_PATH):
        if not fname.endswith('.npz'): continue
        string = fname[:-4]
        string = string.replace('[','')
        string = string.replace(']','')
        string = string.strip()
        string = string.split()
        # Add length to distinguish cases such as [0] and [0,1]
        pattern_list.append([len(string)]+[int(s) for s in string]) 
        data = np.load(os.path.join(PATTERN_PATH, fname))
        pattern_pdata_list.append(data['prob_dist'])
        pattern_cdata_list.append(data['c_class'])

    if len(pattern_list)==0:
        return np.array([]), [], [], [], []

    set_list = [set() for i in range(np.max([len(p) for p in pattern_list]))]
    for i in range(np.max([len(p) for p in pattern_list])):
        for p in pattern_list:
            try:
                set_list[i].add(p[i])
            except:
                continue
    set_list = [np.sort(list(s)) for s in set_list]

    base = [len(s) for s in set_list]
    pattern_dec_list = np.zeros(len(pattern_list), dtype=np.int64)
    for j,p in enumerate(pattern_list):
        pattern_dec_list[j] = pattern2dec(
            np.array(p, dtype=np.int64), set_list, base, add_len=False)

    perm = np.argsort(pattern_dec_list)
    pattern_dec_list = pattern_dec_list[perm]
    pattern_pdata_list = [pattern_pdata_list[i] for i in perm]
    pattern_cdata_list = [pattern_cdata_list[i] for i in perm]

    return pattern_dec_list, pattern_pdata_list, pattern_cdata_list, set_list, base


pattern_dec_list, pattern_pdata_list, pattern_cdata_list, set_list, base = load_pattern_data()
F012 = np.load(os.path.join(PATTERN_PATH, 'F.npy'))


def de2bi(d, N):
    """Decimal number to binary number."""
    d = np.atleast_1d(d)
    power = 2**np.arange(N)
    return np.int_(np.floor((d[...,None]%(2*power))/power))


def bi2de(x):
    """Binary number to decimal number."""
    x = np.atleast_2d(x)
    result = np.zeros(x.shape[0], dtype=int)
    for k,row in enumerate(x):
        y = 0
        for i,j in enumerate(row):
            y += j<<i
        result[k] = y
    return result

def shift_F(F, shift):
    """Given phases F(\vec i) compute F(\vec i + \vec \alpha_{shift}).
    """
    N = np.int(np.log2(len(F)))
    F_shift = np.zeros(2**N, dtype='complex64')
    for i in range(2**N):
        i_vec = de2bi(i, N)
        i_shift = bi2de(np.mod(i_vec + shift, 2))
        F_shift[i] = F[i_shift]
    return F_shift


def _pauli_coeff(j, N, F):
    """c(Z_Q) = \sum_i (-1)^{\alpha_Q \cdot i} F(i)
    """
    alpha_z = de2bi(j, N)
    c = 0
    for i in range(2**N):
        i_vec = de2bi(i, N)
        c = c + (-1)**(np.sum(i_vec*alpha_z))*F[i]
    return c


def pauli_coeff(F):
    """Compute Pauli coefficients of F.
    """
    N = np.int(np.log2(len(F)))

    # Serial
    if "daemon" in current_process()._config:
        c = np.zeros(2**N, dtype='complex64')
        for j in range(2**N):
            c[j] = _pauli_coeff(j,N,F)
    # Parallel
    else:
        with Pool() as pool:
            c = pool.map(partial(_pauli_coeff, F=F, N=N), range(2**N))
    return np.array(c)/2**N


def probability(c, alpha_plaquette, classify=False):
    """Given Pauli coefficients c(Z_Q), obtain probabilities of getting a
    certain plaquette configuration. Optional: classify non-zero Pauli
    coefficients according to plaquette configuration."""
    c = np.conjugate(c)
    N = np.int(np.log2(len(c)))
    # compute state X| 0 0 0 0 0 >
    N_p = alpha_plaquette.shape[0] # number of plaquettes
    c_sum = np.zeros(2**N_p, dtype='complex64')
    if classify: c_class = -np.ones(2**N, dtype=int)
    for j in range(2**N):
        if c[j]==0: continue
        alpha_z = de2bi(j,N)
        plaquette_state = np.mod(
            np.matmul(alpha_z, alpha_plaquette.transpose()), 2)
        ind = bi2de(plaquette_state)
        c_sum[ind] = c_sum[ind] + c[j]
        if classify:
            c_class[j] =  ind
    if classify: return np.abs(c_sum)**2, c_class
    return np.abs(c_sum)**2


def map_F(F, mapping, N_new):
    """Obtain suitable mapping for function _map_F and call it."""
    mapping_new = -np.ones([N_new], dtype=int)
    for j in range(N_new):
        if j in mapping:
            mapping_new[j] = np.argwhere(mapping==j)
    F_mapped = _map_F(F, mapping_new, N_new)
    return F_mapped


def _map_F(F, perm, N_new, N=5):
    """Map F using permutations. Qubits outside conn needed are set to -1.
    Position in perm vector identifies qubit in new mapped system, number is 
    qubit in old system (5 qubits)."""
    F_mapped = np.zeros([2**N_new], dtype='complex64')
    for i in range(2**N_new):
        i_vec_mapped = np.squeeze(de2bi(i, N_new))
        i_vec = np.zeros(N, dtype=int);
        for j in range(len(perm)):
            if perm[j]!=-1:
                i_vec[perm[j]] = i_vec_mapped[j]
        F_mapped[i] = F[bi2de(i_vec)]
    return F_mapped


def plaquette_probabilities(mapping, alpha_plaquette, e_orientation):
    """Map length-one F phases to our system using mapping. Then multiply all
    phases to obtain F_total and get plaquette configuration probabilities."""
    N = len(e_orientation)
    F_phases = np.zeros([mapping.shape[0], 2**N], dtype='complex64')
    for i in range(mapping.shape[0]):
        F_phases[i, :] = map_F(
            F012[e_orientation[mapping[i, 2]], :], mapping[i, :], N)
    F_total = np.ones(2**N, dtype='complex64')
    alpha_path = np.zeros([mapping.shape[0],N], dtype=bool)
    for i,F in enumerate(F_phases):
        alpha_path[i, mapping[i,2]] = True
        shift = np.mod(np.sum(alpha_path[0:i,:],axis=0),2)
        F_total = F_total*shift_F(F, shift)
    c = pauli_coeff(F_total)
    prob_dist, c_class = probability(c, alpha_plaquette, classify=True)
    return prob_dist, c, c_class


def map_length_one_string(X_string, lattice):
    """Given string edges, returns mapping to each length-one string, where
    positions in map are in small 5-qubit system and numbers are in old big
    system. Following the labeling given in Fig. 7. """
    mapping = np.zeros([len(X_string), 5], dtype=int)
    for i, e in enumerate(X_string):
        mapping[i, 2] = e
        position = np.squeeze(lattice.edge_position(e))

        edges_1_2 =  lattice.vertex2edge(lattice.e_vertex[e,0], both=False)
        edges_1_2 = np.setdiff1d(edges_1_2, e)

        edges_4_5 = lattice.vertex2edge(lattice.e_vertex[e,1], both=False)
        edges_4_5 = np.setdiff1d(edges_4_5, e)

        if lattice.e_orientation[e] == 0:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[0] < position[0]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[0] < position[0]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]

        elif lattice.e_orientation[e] == 1:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[1] == position[1]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[1] > position[1]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]

        elif lattice.e_orientation[e] == 2:
            if np.squeeze(lattice.edge_position(edges_1_2[0]))[1] == position[1]:
                mapping[i,0] = edges_1_2[0]
                mapping[i,1] = edges_1_2[1]
            else:
                mapping[i,0] = edges_1_2[1]
                mapping[i,1] = edges_1_2[0]
            if np.squeeze(lattice.edge_position(edges_4_5[0]))[1] < position[1]:
                mapping[i,3] = edges_4_5[0]
                mapping[i,4] = edges_4_5[1]
            else:
                mapping[i,3] = edges_4_5[1]
                mapping[i,4] = edges_4_5[0]
    return mapping


@njit
def move_string(N_row, N_col, X_string_pos):
    """Move string given by edge positions X_string_pos to the lower left
    corner of a lattice with N_row and N_col.
    """
    while True:
        if np.all(_mod(N_row, N_col, X_string_pos - np.array([1, 3], 
            np.float64)) == X_string_pos - np.array([1, 3], np.float64)):
            X_string_pos = X_string_pos - np.array([1, 3], np.float64)
        elif np.all(_mod(N_row, N_col, X_string_pos - np.array([2, 0], 
            np.float64)) == X_string_pos - np.array([2, 0], np.float64)):
            X_string_pos = X_string_pos - np.array([2, 0], np.float64)
        else:
            break
    return X_string_pos


@njit('float64[:,:](int64, int64, float64[:,:])')
def move_away_boundary_e(N_row, N_col, position):
    """Determine if positions of group of edges go through a lattice boundary
    and move it away."""
    YMIN = 0.5
    YMAX = N_row*3-1
    def XMIN(x): return 3*x - 1
    def XMAX(x): return 3*(x-2*N_col+1) - 1

    x_m_array = np.zeros(position.shape[0], dtype=np.float64)

    y_max = np.max(position[:, 1])
    y_min = np.min(position[:, 1])
    s = 1
    i = 1
    while y_min == YMIN and y_max == YMAX:
        position = _mod(N_row, N_col, position + np.array([s*1, 3]))
        s = -s
        y_min = np.min(position[:, 1])
        y_max = np.max(position[:, 1])
        i = i + 1
        assert i < N_row, 'String goes all around system.'
    i = 1
    for j in range(position.shape[0]):
        x_m_array[j] = XMAX(position[j, 0])-position[j, 1]
    x_max = np.min(np.abs(x_m_array))

    for j in range(position.shape[0]):
        x_m_array[j] = XMIN(position[j, 0])-position[j, 1]
    x_min = np.min(np.abs(x_m_array))
    while x_min == 0 and x_max == 0:
        position = _mod(N_row, N_col, position + np.array([2, 0]))
        for j in range(position.shape[0]):
            x_m_array[j] = XMAX(position[j, 0])-position[j, 1]
        x_max = np.min(np.abs(x_m_array))

        for j in range(position.shape[0]):
            x_m_array[j] = XMIN(position[j, 0])-position[j, 1]
        x_min = np.min(np.abs(x_m_array))
        i = i + 1
        assert i < N_col, 'String goes all around system.'
    return position


@njit('int64[:,:](int64, int64, int64[:,:])')
def move_away_boundary_p(N_row, N_col, position):
    """Determine if positions of group of plaquettes go through a lattice 
    boundary and move it away."""
    YMIN = 2
    YMAX = N_row*3-1
    def XMIN(x): return 3*x - 4
    def XMAX(x): return 3*(x-2*N_col+2) - 4

    x_m_array = np.zeros(position.shape[0], dtype=np.int64)

    y_max = np.max(position[:, 1])
    y_min = np.min(position[:, 1])
    s = 1
    i = 1
    while y_min == YMIN and y_max == YMAX:
        position = _mod(
            N_row, N_col, position + np.array([s*1, 3], dtype=np.int64))
        s = -s
        y_min = np.min(position[:, 1])
        y_max = np.max(position[:, 1])
        i = i + 1
        assert i < N_row, 'String goes all around system.'
    i = 1
    for j in range(position.shape[0]):
        x_m_array[j] = XMAX(position[j, 0])-position[j, 1]
    x_max = np.min(np.abs(x_m_array))

    for j in range(position.shape[0]):
        x_m_array[j] = XMIN(position[j, 0])-position[j, 1]
    x_min = np.min(np.abs(x_m_array))
    while x_min == 0 and x_max == 0:
        position = _mod(
            N_row, N_col, position + np.array([2, 0], dtype=np.int64))

        for j in range(position.shape[0]):
            x_m_array[j] = XMAX(position[j, 0])-position[j, 1]
        x_max = np.min(np.abs(x_m_array))

        for j in range(position.shape[0]):
            x_m_array[j] = XMIN(position[j, 0])-position[j, 1]
        x_min = np.min(np.abs(x_m_array))

        i = i + 1
        assert i < N_col, 'String goes all around system.'
    return position


def group_edges(edge, lattice, direct=True):
    """Given edge list, group edges which are adjacent.
    
    Args:
        edge (1d array): edge indices or bool array of length
            lattice.N_edge.
        lattice (lattice object).
        direct (bool): direct lattice grouping or reciprocal.

    Returns:
        edge_group_list (list): list of 1d arrays int. Each 1d array contains 
        edge indices.
    """
    if direct:
        edge2vp = lattice.edge2vertex
    else:
        raise NotImplementedError(
            'Uncomment and use edge2plaquette in hexagonal lattice.')
        # edge2vp = lattice.edge2plaquette
    if edge.dtype == bool:
        N_edge = np.sum(edge)
        edge_group = np.concatenate(
            (np.argwhere(edge), -np.ones((N_edge, 1), dtype=int)), axis=1)
    else:
        N_edge = len(edge)
        edge_group = np.concatenate(
            (np.transpose(np.atleast_2d(edge)), -np.ones((N_edge, 1),
            dtype=int)), 
            axis=1)
    if N_edge == 0:
        return []
    for i in range(N_edge):
        if edge_group[i, 1] == -1:
            edge_group[i, 1] = np.max(edge_group[:, 1])+1
            check = [i]
        else:
            continue
        while check:
            for j in range(N_edge):
                if check[0] == j or edge_group[j, 1] != -1:
                    continue
                intersect = np.intersect1d(
                    edge2vp(edge_group[check[0], 0]), 
                    edge2vp(edge_group[j, 0]))
                if len(intersect) > 0:
                    edge_group[j, 1] = edge_group[check[0], 1]
                    check.append(j)
            check.pop(0)
    edge_group_list = []
    for i in range(np.max(edge_group[:, 1])+1):
        edge_group_list.append(edge_group[edge_group[:, 1] == i, 0])
    return edge_group_list


def X_error_pattern(X_string, 
                    lattice, 
                    lattice_map=HexagonalLattice(6, 6), 
                    plot=False):
    """Given a set of connected edges, X_string, identify it uniquely with a 
    pattern.
    
    A pattern is the set of edge indices where X_string lives when mapped into
    the lower left corner of lattice_map.

    Args:
        X_string (1d array int): adjacent edge indices.
        lattice (lattice object): original lattice where X_string is found.
        lattice_map (lattice object): where X_string is mapped.
        plot (bool): whether to plot X_string in the new and the original 
            lattice.
    Returns:
        pattern (1d array int): edge indices where X_string is located in
            lattice_map.
    """

    X_string_pos = lattice.edge_position(X_string)
    X_string_pos = move_away_boundary_e(
        lattice.N_row, lattice.N_col, X_string_pos)

    # Determine if string goes through a boundary and move it out of boundary
    X_string_pos = move_away_boundary_e(
        lattice_map.N_row, lattice_map.N_col, X_string_pos)
    # Move string to lower left corner
    X_string_pos = move_string(
        lattice_map.N_row, lattice_map.N_col, X_string_pos)
    # Mapped to vertices in small system
    pattern = np.sort(lattice_map.e_position2edge(X_string_pos))

    # Plot results
    if plot:
        lattice_map.plot_lattice(e_numbers=True)
        lattice_map.plot_error(pattern)
        lattice.plot_lattice(e_numbers=True)
        X_error = np.zeros(lattice.N_edge, dtype=bool)
        X_error[X_string] = True
        lattice.plot_error(X_error)

    return pattern


def compute_pattern(pattern, 
                    max_length, 
                    lattice=HexagonalLattice(6, 6), 
                    save=True):
    """Given a pattern, compute data and optionally store it.
    
    Args:
        pattern (1d array int): edge indices of the lattice.
        max_length (int): only compute pattern data if |Conn(pattern)| <= 
            max_length.
        lattice (lattice object): lattice into which patterns are mapped.
        save (bool): whether to save pattern data computed.

    Returns: False if pattern not computed, otherwise prob_dist (1d array  
        float) and c_class (1d array int).
    """
    pattern = np.sort(pattern)

    vertex = np.unique(lattice.edge2vertex(pattern))
    edge = lattice.vertex2edge(vertex, both=False)
    if len(edge)>max_length: return False
    print(f'Computing pattern: {pattern}, length {len(edge)}...')

    # Sort plaquettes in \cal{B}_{pattern}
    plaquette = np.unique(lattice.v_plaquette[vertex])
    p_position = move_away_boundary_p(
        lattice.N_row, lattice.N_col, 
        np.atleast_2d(lattice.p_position[plaquette, :]))
    ind = np.lexsort((p_position[:,1], p_position[:,0]))
    plaquette = plaquette[ind]

    # Sort edges in Conn(pattern)
    e_position = move_away_boundary_e(
        lattice.N_row, lattice.N_col, lattice.edge_position(edge))
    ind = np.lexsort((e_position[:,1], e_position[:,0]))
    edge = edge[ind]
    e_orientation = lattice.e_orientation[edge]

    # Map for F phases of each length-one string
    mapping = map_length_one_string(pattern, lattice)
    for i in range(np.shape(mapping)[0]):
        for j in range(np.shape(mapping)[1]):
            mapping[i,j] = np.argwhere(mapping[i,j]==edge)

    # Build alpha plaquette
    N = len(edge)
    alpha_plaquette = np.zeros([len(plaquette), N], dtype=bool)
    for i in range(len(plaquette)):
        p_edge = np.squeeze(lattice.plaquette2edge(plaquette[i]))
        for e in p_edge:
            if e in edge:
                ind = np.argwhere(edge==e)
                alpha_plaquette[i, ind] = True

    # Compute probabilities
    prob_dist, c, c_class = plaquette_probabilities(
        mapping, alpha_plaquette, e_orientation)

    # Save results
    if save:
        np.savez(os.path.join(PATTERN_PATH, str(pattern)),
                 prob_dist=prob_dist, c=c, c_class=c_class)
        print(f'Pattern saved in {os.path.join(PATTERN_PATH, str(pattern))}')
    return prob_dist, c_class


def compute_all_patterns(max_length=14):
    """Compute and save all patterns with |Conn(pattern)| <= max_length.
    """
    end_time = time.time()
    for _ in range(int(1e6)):
        p_X = 0.2
        lattice = HexagonalLattice(6,6)
        X_error = np.random.choice(2, lattice.N_edge, p=[1-p_X, p_X])
        X_error = X_error.astype(bool)
        X_error_group = group_edges(X_error, lattice, direct=True)
        for X_string in X_error_group:
            try:
                pattern = X_error_pattern(
                    X_string, lattice, HexagonalLattice(6, 6))
            except Exception as error:
                print("Pattern error "+repr(error))
                continue

            if os.path.isfile(os.path.join(PATTERN_PATH, str(pattern)+'.npz')):
                continue

            try:
                start_time = time.time()
                result = compute_pattern(pattern, max_length, save=True)
                if result:
                    end_time = time.time()
                    print('Elapsed time %s minutes' 
                    % str((end_time - start_time)/60.0))
            except Exception as error:
                print(repr(error))

        # if no new pattern found in last 300 seconds: return
        if time.time() - end_time > 300:
            print('Pattern data ready.')
            return

if __name__=='__main__':
    compute_all_patterns()
